module InvokeFunction where

import Prelude

import Caching as Caching
import Control.Monad.Aff (Aff, makeAff)
import Control.Monad.Aff.Console (CONSOLE, logShow)
import Control.Monad.Eff.Exception (error)
import Control.Monad.Free (Free, hoistFree)
import Counters as Counters
import Data.Foldable (foldr)
import Data.Maybe (Maybe(..))
import InvokeSpec (Aspect(..), CallSpec(..), FunctionInvocation, emptyInvocation, getFnCallSpec, getFunctionDetails)
import Logging as Logging
import RPC as RPC
import Hystrix as Hystrix

foreign import getTimestamp :: Unit -> Number

-- Base data constructors for the Free Type
data InvokeFunctionFC a b c = InvokeFunction (a -> b) a (b -> c) | End String c

-- Instance declaration for the InvokeFunction command
instance functionCommandF :: Functor (InvokeFunctionFC a b) where
  map f (InvokeFunction f' a r) = InvokeFunction f' a (f <<< r)
  map f (End str a) = End str (f a)

-- Free command to be used by clients
type FreeCommand a b = Free (InvokeFunctionFC a b)

-- Target free that adds the details specified in the deployment spec
data InterpretCommand a b c = InterpretCommand (a -> b) a (b -> c) (Array CallSpec) | EndF String c


-- Transform the program, inserting the call specification at each node
transform :: forall a b c.
             Free (InvokeFunctionFC a b) c
             -> Free (InterpretCommand a b) c

transform ast = hoistFree transformer ast where
  transformer :: forall a' b' c'. InvokeFunctionFC a' b' c'  -> InterpretCommand a' b' c'
  transformer command =
    case command of
      (InvokeFunction f' a r) -> InterpretCommand f' a r (generateCallSpec f')
      (End s c) -> EndF s c

  generateCallSpec :: forall a' b'. (a' -> b') -> Array CallSpec
  generateCallSpec function =
    let functionDetails = getFunctionDetails function in
    getFnCallSpec functionDetails.functionName functionDetails.moduleName
    
-- interpreter 
interpret :: forall a b c eff.
             InterpretCommand a b c
             -> Aff (console :: CONSOLE | eff) c

interpret command = callFunc command where
  handleInvocationSpec :: forall a' b'.
                          Aspect
                          -> CallSpec
                          -> FunctionInvocation a' b'
                          -> FunctionInvocation a' b'
                          
  handleInvocationSpec aspect spec invocationData =
    case spec of
      CachingSpec _ -> Caching.action aspect spec invocationData
      MetricsSpec _ -> Counters.action aspect spec invocationData
      LoggingSpec _ -> Logging.action aspect spec invocationData
      RPCSpec     _ -> RPC.action aspect spec invocationData
      HystrixSpec _ -> Hystrix.action aspect spec invocationData

  -- Function to determine if the function is called etc...
  beforeInvoke :: forall a' b'.
                  (a' -> b')
                  -> a'
                  -> Array CallSpec
                  -> FunctionInvocation a' b'
  beforeInvoke function arguments specs = let newInvocation = emptyInvocation function in
    foldr (handleInvocationSpec BeforeCall) (newInvocation { arguments = Just $ arguments }) specs  

  -- Handle the result of the function call
  afterInvoke :: forall a' b'.
                 FunctionInvocation a' b'
                 -> Array CallSpec
                 -> FunctionInvocation a' b'
  afterInvoke invocationData specs = foldr
                                     (handleInvocationSpec AfterCall)
                                     invocationData
                                     specs


  -- | For a spec that defines an externCallEndpoint, instead of invoking
  -- the function, handoff to the RPC.callRPC function to do the nework call.
  -- Additionally, for calls to services that havea `hystrix` specification,
  -- handoff to the Hystrix module.
  --
  -- If the invocationData generated by the beforeCall function defines a result to
  -- be used, then return that instead of the resut of function application.
  callFunc :: forall a' b' c' eff'.
              InterpretCommand a' b' c'
              -> Aff (console :: CONSOLE | eff') c'
  callFunc command = 
    case command of
      (InterpretCommand f args rst specs) -> do
        let invocationData = beforeInvoke f args specs
        case invocationData.result of
          Just value -> pure (rst value)
          Nothing -> do
             result <- case invocationData.externCallEndpoint of
                         Just endpoint -> 
                             makeAff $ \err succ ->  
                                      let isHystrixManaged = invocationData.isHystrixManaged
                                          canCallFunction = Hystrix.canCallFunction invocationData in

                                      case [isHystrixManaged, canCallFunction] of
                                        [true, false] -> err $ error "denied by hystrix"
                                        [true, true] -> 
                                            let wrappedHandlers = Hystrix.wrapServiceCall err succ
                                                errorCallback = wrappedHandlers.wrappedErrorCallback
                                                successCallback = wrappedHandlers.wrappedSuccessCallback in
                                            RPC.callRPC { endpoint: endpoint
                                                        , args: args
                                                        , errorCallback: errorCallback
                                                        , successCallback: successCallback}
                                        _ -> RPC.callRPC { endpoint: endpoint
                                                         , args: args
                                                         , errorCallback: err
                                                         , successCallback: succ }
                         Nothing ->
                             if invocationData.isHystrixManaged then
                                 makeAff $ \err succ -> 
                                             if Hystrix.canCallFunction invocationData 
                                             then 
                                                 let wrappedHandlers = Hystrix.wrapServiceCall err succ in
                                                 wrappedHandlers.wrappedSuccessCallback <<< f $ args
                                             else err $ error "denied by hystrix"
                             else 
                                 pure $ f args
 
             pure (rst $ (\_ -> result) $ afterInvoke (invocationData { result = Just $ result }) specs)

      (EndF string a) -> do
        logShow "reached end of program"
        pure a

